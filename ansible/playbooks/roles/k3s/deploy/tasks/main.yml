- name: Set variables for the deployment
  ansible.builtin.set_fact:
      cloudflare_cert: "cloudflare.pem"
      cloudflare_key: "cloudflare.key"
      kubeconfig: "/home/{{ ansible_user }}/.kube/config"
      cronjobs:
          - {
                name: "parse-feeds",
                schedule: "*/6 * * * *", # Every 6 minutes
                command: "./manage.py parse_feeds",
            }
          - {
                name: "create-recommendations",
                schedule: "20 15 * * *", # 3:20 PM
                command: "./manage.py create_recommendations",
            }
          - {
                name: "send-recommendations",
                schedule: "45 18 * * 1", # 6:45 PM every Monday
                command: "./manage.py send_recommendations",
            }
          - {
                name: "fetch-itunes-chart",
                schedule: "15 7 * * *", # 7:15 AM
                command: "./manage.py fetch_itunes_chart",
            }
          - {
                name: "clear-sessions",
                schedule: "5 5 * * *", # 5:05 AM
                command: "./manage.py clearsessions",
            }

- name: Create cloudflare_certs list
  ansible.builtin.set_fact:
      cloudflare_certs: ["{{ cloudflare_cert }}", "{{ cloudflare_key }}"]
  changed_when: false

- name: Copy Cloudflare certs to target node
  ansible.builtin.copy:
      src: "{{ playbook_dir }}/../certs/{{ item }}"
      dest: "/tmp/{{ item | basename }}"
  loop: "{{ cloudflare_certs }}"

- name: Create Kubernetes TLS Secret
  ansible.builtin.shell: |
      kubectl create secret tls cloudflare-origin-cert \
          --cert=/tmp/{{ cloudflare_cert }} \
          --key=/tmp/{{ cloudflare_key }} \
          -n default --dry-run=client -o yaml | kubectl apply -f -
  args:
      creates: "/tmp/cloudflare-origin-cert.created"
  environment:
      KUBECONFIG: "{{ kubeconfig }}"

- name: Remove certs from /tmp after secret is created
  file:
      path: "/tmp/{{ item }}"
      state: absent
  loop: "{{ cloudflare_certs }}"

- name: Label the nodes
  ansible.builtin.shell: |
      kubectl label nodes {{ hostvars[item].hostname }} role={{ hostvars[item].role }} --overwrite
  loop: "{{ groups['agents'] + groups['server'] }}"
  environment:
      KUBECONFIG: "{{ kubeconfig }}"

- name: Get Django hosts
  ansible.builtin.set_fact:
      django_hosts: "{{ groups['agents'] | map('extract', hostvars) | selectattr('role', 'equalto', 'django') | list }}"
  changed_when: false

- name: Get the current image of the django-app pod
  ansible.builtin.command: kubectl get pods -l app=django-app -o jsonpath='{.items[0].spec.containers[0].image}' -n default
  register: current_image
  changed_when: false
  ignore_errors: true
  environment:
      KUBECONFIG: "{{ kubeconfig }}"

- name: Set default image if current image is empty
  ansible.builtin.set_fact:
      image: "{{ current_image.stdout | default(docker_image) }}"
  changed_when: false

- name: Apply spec files
  vars:
      database_url: "postgresql://postgres:{{ postgres_password }}@postgres.default.svc.cluster.local:5432/postgres"
      redis_url: "redis://redis.default.svc.cluster.local:6379/0"
      replicas: "{{ django_hosts|length }}"
  ansible.builtin.command: >
      kubectl apply -f -
  args:
      stdin: "{{ lookup('template', item + '.j2') }}"
  loop:
      - configmap.yaml
      - secrets.yaml
      - ingress.yaml
      - postgres_pv.yaml
      - postgres_pvc.yaml
      - postgres_statefulset.yaml
      - postgres_service.yaml
      - redis_deployment.yaml
      - redis_service.yaml
      - django_deployment.yaml
      - django_service.yaml
      - django_cronjobs.yaml
  environment:
      KUBECONFIG: "{{ kubeconfig }}"

- name: Add scripts to access the deployment
  ansible.builtin.template:
      src: "{{ item }}.j2"
      dest: "{{ item }}"
      mode: "u+x"
  loop:
      - deploy.sh
      - manage.sh
      - psql.sh

- name: Run the deploy script to do Django migrations etc
  ansible.builtin.shell: |
      ./deploy.sh
  environment:
      IMAGE: "{{ image }}"
