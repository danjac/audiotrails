#!/usr/bin/env bash

set -o errexit
# Check if $IMAGE is not set or is empty

if [ -z "$IMAGE" ]; then
  echo "ERROR: IMAGE environment variable is not set."
  exit 1
fi

echo "Deploying image $IMAGE to Kubernetes..."

export KUBECONFIG="{{ kubeconfig }}"

echo "Running pre-deployment tasks..."

# Create new release job

release_job_id=$(head -c 12 /dev/urandom | base64 | tr -dc 'a-z0-9' | head -c 12)
release_job_name="django-release-job-$release_job_id"

release_job_yaml=$(cat <<EOF
apiVersion: batch/v1
kind: Job
metadata:
  name: $release_job_name
spec:
  template:
    spec:
      containers:
        - name: django
          image: $IMAGE
          command: ["/bin/sh", "-c"]
          args: ["./release.sh"]
          envFrom:
            - configMapRef:
                name: configmap
            - secretRef:
                name: secrets
      restartPolicy: OnFailure
      nodeSelector:
        role: jobrunner

EOF
)

# Pass the resulting YAML content to kubectl apply
echo "$release_job_yaml" | kubectl apply -f - -n default

kubectl wait --for=condition=complete job/$release_job_name --timeout=60s

release_pod_name=$(kubectl get pods -l job-name=$release_job_name -o jsonpath='{.items[0].metadata.name}')
release_pod_status=$(kubectl get pod $release_pod_name -o jsonpath='{.status.phase}')

# Log the output of the job for debugging purposes
kubectl logs $release_pod_name

# Delete the job after it has completed

kubectl delete pod $release_pod_name
kubectl delete job $release_job_name

# Job failed, so exit
if [[ $release_pod_status != "Succeeded" ]]; then
    echo "Job failed with status $release_pod_status, exiting..."
    exit 1
fi

echo "Deploying application..."

kubectl set image deployment/django-app django=${IMAGE} -n default
kubectl rollout status deployment/django-app -n default

echo "Updating cron jobs..."

{% for cronjob in cronjobs %}
kubectl set image cronjob/{{ cronjob.name }} django=${IMAGE} -n default
{% endfor %}
